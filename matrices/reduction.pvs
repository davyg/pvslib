
bloc : THEORY BEGIN

  IMPORTING matrices

  TL(n:nat)(M:SquareMatrix(n)) : SquareMatrix(n-1)
  TR(n:nat)(M:SquareMatrix(n)) : VectorN(n-1)
  BL(n:nat)(M:SquareMatrix(n)) : VectorN(n-1)
  BR(n:nat)(M:SquareMatrix(n)) : real

  BCons(n:nat)(TL:SquareMatrix(n-1), TR:VectorN(n-1), BL:VectorN(n-1), BR:real) : SquareMatrix(n)

END bloc

recursor : THEORY BEGIN

  IMPORTING matrices

  predSup(x:nat) : TYPE = { (n:nat, l:list[Square]) | n > 0 and length(l) = x and
    forall (x:Square) : member(x, l) => rows(x) = n }

  matRec : LEMMA forall (s:nat, P : [predSup(s) -> bool]) :
    (forall (x:predSup(s)) : x`1 = 1 => P(x)) =>
    (forall (n:nat) : (forall (x:predSup(s)) : x`1 = n => P(x)) =>
       (forall (x:predSup(s)) : x`1 = n + 1 => P(x))) =>
    (forall (x:predSup(s)) : P(x))

END recursor

% Contains all you need as soon as you specialized matrix with a n
myMatrices[n:nat] : THEORY BEGIN
  IMPORTING matrices
  
  SqMat : TYPE = SquareMatrix(n)
  Id : SqMat = Id(n)

  Vec  : TYPE = VectorN(n)
  zero : Vec = zero(n)
  NVec : TYPE = {x : Vec | x /= zero }
  
  mult(M:SqMat, v:Vec) : Vec

  * : [SqMat, Vec -> Vec] = mult

  Diag : set[SqMat] = { M : SqMat | forall (i, j:below[n]) : (i /= j) => entry(M)(i, j) = 0 }

END myMatrices

eigen[n:nat] : THEORY BEGIN
  IMPORTING myMatrices[n]
  
  spectrum(M:SqMat) : set[real] = {x : real | exists (v:NVec) : M * v = x * v }

  eigenSpace(M:SqMat, x:real) : set[Vec] = {v : NVec |  M * v = x * v }
END eigen

stability[n:nat] : THEORY BEGIN
  IMPORTING myMatrices[n]

  stable?(M : SqMat, s:set[Vec]) : bool = forall (x : (s)) : member(M * x, s)

END stability

orthogonality[n:nat] : THEORY BEGIN
  IMPORTING myMatrices[n]
  
  Orth : set[SqMat] = { M : SqMat | M * transpose(M) = Id }

  orth(F : set[Vec]) : set[Vec] = { x : Vec | forall (y : (F)) : x * y = 0 }
END orthogonality

symmetry[n:nat] : THEORY BEGIN
  IMPORTING myMatrices[n]
  
  Sym : set[SqMat] = { M : SqMat | M = transpose(M) }
END symmetry


% All reduction related proof
reduction[n:nat] : THEORY BEGIN

  IMPORTING orthogonality
  IMPORTING symmetry[n]
  IMPORTING eigen[n]
  IMPORTING stability[n]
  IMPORTING recursor
  IMPORTING bloc
  
  lem1 : LEMMA forall (M : (Sym)) :
    forall (x, y : (spectrum(M))) : (x /= y) =>
      forall (u : (eigenSpace(M, x))) (v : (eigenSpace(M, y))) :
        u * v = 0

  lem2 : LEMMA forall (M : (Sym)) :
    forall (F:set[Vec]) :
      stable?(M, F) => stable?(M, orth[n](F))

  red : THEOREM
    forall (S : (Sym)) :
      exists (O : (Orth[n]), D : (Diag[n])) :
        S = O * D * transpose(O)

END reduction
